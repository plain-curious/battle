<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Custom WebGL Battle Engine</title>
    <style>
        body {
            background-color: #202020;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none; /* Prevent scroll on mobile */
        }
        #game-wrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 10px solid #8b9bb4; /* Gameboy Grey */
            border-radius: 10px;
            background-color: #f8f8d8; 
            /* Responsive sizing */
            width: 100%;
            max-width: 600px;
            aspect-ratio: 600/550;
            max-height: 90vh;
        }
        #game-container {
            width: 100%;
            height: 100%;
        }
        /* Instructions CSS removed */
        #loading-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-weight: bold;
            z-index: 0;
        }
    </style>
    <!-- Import Phaser 3 Framework -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>

<div id="game-wrapper">
    <div id="loading-msg">Loading Battle Engine...</div>
    <!-- Instructions HTML removed -->
    <div id="game-container" style="position: relative; z-index: 1;"></div>
</div>

<script>
// ========================================================================================
// 1. USER CONFIGURATION ZONE - EDIT THIS TO CUSTOMIZE YOUR BATTLE
// ========================================================================================

const BATTLE_CONFIG = {
    // VISUAL SETTINGS
    backgroundUrl: "https://i.postimg.cc/Dw9Mr47H/BG.png", // New Background URL
    colors: {
        background: 0xf8f8d8, // Classic Gameboy Greenish-White (Fallback)
        uiBox: 0x2e4053,      // Dark text box color
        uiText: 0xffffff,     // White text
        healthBarFull: 0x2ecc71,
        healthBarLow: 0xe74c3c
    },

    // TEXT MESSAGES
    text: {
        intro: "A wild BORING WEEKEND appeared!",
        win: "Boring Weekend fainted!",
        lose: "The weekend was wasted...",
        whatDo: "What will JCC do?"
    },

    // PLAYER CONFIGURATION
    player: {
        name: "JCC",
        maxHp: 300, 
        spriteUrl: "https://i.postimg.cc/76gJQd8h/JCClogo.png", 
        fallbackColor: 0xe74c3c, // Red (Excitement)
        scale: 0.3, // Drastically reduced scale for large high-res images
        x: 150, y: 300, 
        moves: [
            { name: "COSPLAY", power: 35, type: "special", text: "dazzled with COSPLAY!" },
            { name: "ACTIVITIES", power: 25, type: "physical", text: "joined ACTIVITIES!" },
            { name: "GAMING ARENA", power: 45, type: "special", text: "dominated the GAMING ARENA!" },
            { name: "LIVE PERFORMANCES", power: 999, type: "special", text: "rocked out with LIVE PERFORMANCES!" }
        ]
    },

    // ENEMY CONFIGURATION
    enemy: {
        name: "BORING WEEKEND",
        maxHp: 500, 
        spriteUrl: "https://i.postimg.cc/9QRdYxf6/weekend.png", 
        fallbackColor: 0x7f8c8d, // Grey (Boring)
        scale: 0.25, // Adjusted to be between 0.2 and 0.3
        x: 450, y: 150,
        moves: [
            { name: "STARE AT CEILING", power: 30, type: "physical", text: "stared at the ceiling." }, 
            { name: "TV RERUNS", power: 50, type: "special", text: "played boring TV RERUNS!" },
            { name: "DOOMSCROLL", power: 60, type: "special", text: "used THE ENDLESS DOOMSCROLL!" },
            { name: "UNNECESSARY NAP", power: 40, type: "status", text: "took an UNNECESSARY NAP!" }
        ]
    }
    // MIDDLE OBJECT REMOVED
};

// ========================================================================================
// 2. ENGINE LOGIC (WEBGL RENDERER & GAME LOOP)
// ========================================================================================

class BattleScene extends Phaser.Scene {
    constructor() {
        super({ key: 'BattleScene' });
    }

    preload() {
        // Safe load: Handle errors if images are missing or blocked by CORS
        this.load.on('loaderror', (fileObj) => {
            console.warn("Could not load file:", fileObj.key);
        });

        const loadIfValid = (key, url) => {
            if (url && typeof url === 'string' && url.trim().length > 0) {
                this.load.image(key, url);
            }
        };

        loadIfValid('background', BATTLE_CONFIG.backgroundUrl);
        loadIfValid('player', BATTLE_CONFIG.player.spriteUrl);
        loadIfValid('enemy', BATTLE_CONFIG.enemy.spriteUrl);
    }

    create() {
        const loadingMsg = document.getElementById('loading-msg');
        if (loadingMsg) loadingMsg.style.display = 'none';

        this.turn = 'player'; 
        this.isAnimating = false;

        // 1. Setup Background
        if (this.textures.exists('background')) {
            this.bgImage = this.add.image(this.scale.width / 2, this.scale.height / 2, 'background');
            // Scale to fill the screen (cover mode)
            let scaleX = this.scale.width / this.bgImage.width;
            let scaleY = this.scale.height / this.bgImage.height;
            let scale = Math.max(scaleX, scaleY);
            this.bgImage.setScale(scale);
            this.bgImage.setDepth(-1000); // Ensure it is behind everything
        } else {
            this.cameras.main.setBackgroundColor(BATTLE_CONFIG.colors.background);
        }

        // 2. Create Objects (Sorted by Y position for correct depth)
        // We create them, then setDepth based on Y to ensure 2.5D perspective
        
        this.player = this.createCharacter('player', BATTLE_CONFIG.player);
        this.enemy = this.createCharacter('enemy', BATTLE_CONFIG.enemy);
        // Middle object creation removed

        // 3. Create UI (Always on top)
        this.createUI();

        // 4. Start Intro
        this.typewriteText(BATTLE_CONFIG.text.intro, () => {
            this.showMenu();
        });

        // 5. Input Handling (Keyboard)
        this.input.keyboard.on('keydown', (event) => this.handleInput(event));
    }

    createCharacter(key, config) {
        let sprite;
        if (this.textures.exists(key)) {
            sprite = this.add.image(config.x, config.y, key);
            sprite.setScale(config.scale);
            // Force Linear filter (Smoothing) explicitly
            if (sprite.texture) {
                sprite.texture.setFilter(Phaser.Textures.FilterMode.LINEAR);
            }
        } else {
            // Fallback Graphics
            let graphics = this.add.graphics();
            graphics.lineStyle(2, 0x000000, 1);
            graphics.fillStyle(config.fallbackColor, 1);
            graphics.fillRect(-32, -32, 64, 64);
            graphics.strokeRect(-32, -32, 64, 64);
            
            // Directional Hint
            graphics.fillStyle(0x000000, 1);
            if (key === 'player') {
                 graphics.fillRect(-10, -32, 5, 10); 
                 graphics.fillRect(5, -32, 5, 10); 
            } else {
                graphics.fillRect(-15, -10, 5, 5); 
                graphics.fillRect(10, -10, 5, 5); 
            }

            sprite = this.add.container(config.x, config.y, [graphics]);
            sprite.setSize(64, 64);
        }
        
        sprite.name = config.name;
        sprite.hp = config.maxHp;
        sprite.maxHp = config.maxHp;
        sprite.moves = config.moves;
        sprite.isPlayer = (key === 'player');
        
        // Shadow removed per request
        // let shadow = this.add.ellipse(config.x, config.y + 40, 80, 20, 0x000000, 0.2);
        
        // Set depth based on Y position (lower on screen = closer to camera)
        sprite.setDepth(config.y);

        return sprite;
    }

    // createMiddleObject removed

    createUI() {
        // --- Health Bars ---
        this.enemyHP = this.addHealthBar(50, 50, BATTLE_CONFIG.enemy.name);
        this.playerHP = this.addHealthBar(350, 250, BATTLE_CONFIG.player.name);
        this.updateHealthUI();

        // --- Dialog Box ---
        let boxGraphics = this.add.graphics();
        boxGraphics.fillStyle(BATTLE_CONFIG.colors.uiBox, 1);
        boxGraphics.fillRect(0, 400, 600, 150);
        
        boxGraphics.lineStyle(4, 0xffffff, 1);
        boxGraphics.strokeRect(4, 404, 592, 142);
        
        this.mainText = this.add.text(30, 420, "", { 
            font: "24px Courier", 
            fill: "#ffffff", 
            wordWrap: { width: 540 } 
        });
        
        // Ensure UI is always on top
        boxGraphics.setDepth(100);
        this.mainText.setDepth(101);
        this.enemyHP.setDepth(100);
        this.playerHP.setDepth(100);

        // --- Menu Container ---
        this.menuContainer = this.add.container(30, 460);
        this.menuContainer.setDepth(102);
        
        BATTLE_CONFIG.player.moves.forEach((move, index) => {
            let xPos = (index % 2) * 280; 
            let yPos = Math.floor(index / 2) * 45; // Increased spacing slightly for touch

            // Make text interactive for clicking
            let txt = this.add.text(xPos, yPos, `${index + 1}. ${move.name}`, { 
                font: "20px Courier", 
                fill: "#ffffff",
                backgroundColor: null
            })
            .setInteractive({ useHandCursor: true })
            .on('pointerover', () => txt.setStyle({ fill: '#ffff00' }))
            .on('pointerout', () => txt.setStyle({ fill: '#ffffff' }))
            .on('pointerdown', () => {
                if (this.turn === 'player' && !this.isAnimating) {
                    this.performMove(this.player, this.enemy, move);
                }
            });

            this.menuContainer.add(txt);
        });
        this.menuContainer.setVisible(false);
    }

    addHealthBar(x, y, name) {
        let container = this.add.container(x, y);
        
        let hudBg = this.add.graphics();
        hudBg.fillStyle(0xffffff, 0.8);
        hudBg.fillRoundedRect(-10, -5, 220, 60, 5);
        hudBg.lineStyle(2, 0x000000, 1);
        hudBg.strokeRoundedRect(-10, -5, 220, 60, 5);
        
        let nameText = this.add.text(0, 0, name, { font: "bold 20px Courier", fill: "#000" });
        let hpLabel = this.add.text(0, 25, "HP:", { font: "bold 16px Courier", fill: "#000" });

        let bg = this.add.rectangle(30, 32, 160, 12, 0x000000).setOrigin(0);
        let bgInner = this.add.rectangle(32, 34, 156, 8, 0xffffff).setOrigin(0);
        let fill = this.add.rectangle(32, 34, 156, 8, BATTLE_CONFIG.colors.healthBarFull).setOrigin(0);
        
        container.add([hudBg, nameText, hpLabel, bg, bgInner, fill]);
        container.fillBar = fill; 
        return container;
    }

    updateHealthUI() {
        let pPct = Math.max(0, this.player.hp / this.player.maxHp);
        this.tweens.add({
            targets: this.playerHP.fillBar,
            width: 156 * pPct,
            duration: 200,
            ease: 'Power2'
        });
        this.playerHP.fillBar.fillColor = pPct < 0.2 ? BATTLE_CONFIG.colors.healthBarLow : BATTLE_CONFIG.colors.healthBarFull;

        let ePct = Math.max(0, this.enemy.hp / this.enemy.maxHp);
        this.tweens.add({
            targets: this.enemyHP.fillBar,
            width: 156 * ePct,
            duration: 200,
            ease: 'Power2'
        });
        this.enemyHP.fillBar.fillColor = ePct < 0.2 ? BATTLE_CONFIG.colors.healthBarLow : BATTLE_CONFIG.colors.healthBarFull;
    }

    typewriteText(text, callback) {
        this.mainText.setText("");
        this.menuContainer.setVisible(false);
        let length = text.length;
        let i = 0;
        
        if(this.textTimer) this.textTimer.remove();

        this.textTimer = this.time.addEvent({
            callback: () => {
                this.mainText.text += text[i];
                i++;
                if (i === length && callback) {
                    this.time.delayedCall(1000, callback);
                }
            },
            repeat: length - 1,
            delay: 30
        });
    }

    showMenu() {
        if (this.turn === 'player') {
            this.mainText.setText(BATTLE_CONFIG.text.whatDo);
            this.menuContainer.setVisible(true);
            this.isAnimating = false; 
        } else {
            this.time.delayedCall(1000, () => {
                if(this.enemy.hp > 0) {
                    let randomMove = Phaser.Math.RND.pick(this.enemy.moves);
                    this.performMove(this.enemy, this.player, randomMove);
                }
            });
        }
    }

    handleInput(event) {
        if (this.turn !== 'player' || this.isAnimating) return;

        let keyIndex = parseInt(event.key) - 1;
        if (keyIndex >= 0 && keyIndex < BATTLE_CONFIG.player.moves.length) {
            let move = BATTLE_CONFIG.player.moves[keyIndex];
            this.performMove(this.player, this.enemy, move);
        }
    }

    performMove(attacker, defender, move) {
        this.isAnimating = true;
        this.menuContainer.setVisible(false);
        
        let msg = `${attacker.name} ${move.text}`;
        
        this.typewriteText(msg, () => {
            if (!attacker.isPlayer) {
                this.typewriteText("It's not very effective...", () => {
                    this.animateMove(attacker, defender, move);
                });
            } else {
                this.animateMove(attacker, defender, move);
            }
        });
    }

    animateMove(attacker, defender, move) {
        // SPECIAL: LIVE PERFORMANCES
        if (move.name === "LIVE PERFORMANCES") {
            let colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff];
            this.time.addEvent({
                delay: 100,
                repeat: 10, 
                callback: () => {
                    const color = Phaser.Math.RND.pick(colors);
                    if (this.bgImage) {
                        this.bgImage.setTint(color);
                    } else {
                        this.cameras.main.setBackgroundColor(color);
                    }
                }
            });

            this.tweens.add({
                targets: attacker,
                y: attacker.y - 40,
                scaleX: attacker.scale * 1.2,
                scaleY: attacker.scale * 1.2,
                duration: 120,
                yoyo: true,
                repeat: 5,
                onComplete: () => {
                    if (this.bgImage) {
                        this.bgImage.clearTint();
                    } else {
                        this.cameras.main.setBackgroundColor(BATTLE_CONFIG.colors.background);
                    }
                    attacker.setScale(BATTLE_CONFIG.player.scale); 
                    this.hitTarget(attacker, defender, move);
                }
            });
            return;
        }

        if (move.type === 'physical') {
            let direction = attacker.isPlayer ? 1 : -1;
            this.tweens.add({
                targets: attacker,
                x: attacker.x + (50 * direction),
                y: attacker.y - 20,
                yoyo: true,
                duration: 100,
                ease: 'Power1',
                onComplete: () => this.hitTarget(attacker, defender, move)
            });
        } else if (move.type === 'status') {
            this.tweens.add({
                targets: attacker,
                y: attacker.y - 10,
                yoyo: true,
                duration: 200,
                repeat: 1,
                onComplete: () => this.hitTarget(attacker, defender, move)
            });
        } else {
            this.tweens.add({
                targets: attacker,
                alpha: 0.2,
                yoyo: true,
                duration: 80,
                repeat: 3,
                onComplete: () => this.hitTarget(attacker, defender, move)
            });
        }
    }

    hitTarget(attacker, defender, move) {
        let damage = move.power;

        if (!attacker.isPlayer && damage > 0) {
            damage = Math.floor(damage / 2);
        }

        defender.hp -= damage;
        
        if (move.power < 0) {
             if (attacker === defender) {
                 attacker.hp -= move.power;
             } else {
                 defender.hp -= move.power;
             }
        }

        if(defender.hp > defender.maxHp) defender.hp = defender.maxHp;
        if(attacker.hp > attacker.maxHp) attacker.hp = attacker.maxHp;

        if (move.power < 0) {
             this.cameras.main.flash(500, 0, 255, 0);
             this.updateHealthUI();
             this.checkWinCondition(defender);
             return;
        }

        this.cameras.main.shake(100, 0.01);
        this.tweens.add({
            targets: defender,
            x: defender.x + (Math.random() * 20 - 10),
            y: defender.y + (Math.random() * 20 - 10),
            duration: 50,
            repeat: 5,
            yoyo: true,
            onComplete: () => {
                // Reset position to exact coords
                defender.x = defender.isPlayer ? BATTLE_CONFIG.player.x : BATTLE_CONFIG.enemy.x;
                defender.y = defender.isPlayer ? BATTLE_CONFIG.player.y : BATTLE_CONFIG.enemy.y;
                
                this.updateHealthUI();
                this.checkWinCondition(defender);
            }
        });
    }

    checkWinCondition(victim) {
        if (victim.hp <= 0) {
            victim.hp = 0;
            this.updateHealthUI();
            
            this.tweens.add({
                targets: victim,
                y: victim.y + 50,
                alpha: 0,
                duration: 1000,
                onComplete: () => {
                     let winMsg = victim.isPlayer ? BATTLE_CONFIG.text.lose : BATTLE_CONFIG.text.win;
                     this.typewriteText(winMsg, () => {
                        // If the enemy died (Player won), trigger victory sequence
                        if (!victim.isPlayer) {
                            this.time.delayedCall(1000, () => this.triggerWinSequence());
                        }
                     });
                }
            });

        } else {
            this.turn = (this.turn === 'player') ? 'enemy' : 'player';
            this.showMenu();
        }
    }

    triggerWinSequence() {
        // Clear the bottom dialogue box
        this.mainText.setText("");
        
        // Create Big Victory Text in the center of the text box
        // Box starts at 400, height 150. Center Y is roughly 475.
        let victoryText = this.add.text(this.scale.width / 2, 475, "JCC WINS!", {
            font: "bold 60px Courier",
            fill: "#ffffff",
            stroke: "#000000",
            strokeThickness: 6,
            align: "center"
        }).setOrigin(0.5).setDepth(200).setAlpha(0);

        // Animate the text popping in
        this.tweens.add({
            targets: victoryText,
            alpha: 1,
            scale: { from: 0.5, to: 1.2 },
            duration: 1000,
            ease: 'Back.out'
        });

        // --- CONFETTI EFFECT ---
        
        // 1. Generate a simple white square texture for confetti
        if (!this.textures.exists('confetti')) {
            let graphics = this.make.graphics({x: 0, y: 0, add: false});
            graphics.fillStyle(0xffffff, 1);
            graphics.fillRect(0, 0, 10, 10);
            graphics.generateTexture('confetti', 10, 10);
        }
        
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
        
        // 2. Create Left Emitter (Shooting Up and Right)
        this.add.particles(0, this.scale.height, 'confetti', {
            speed: { min: 400, max: 700 },
            angle: { min: -75, max: -30 }, // Angles in degrees (0 is right, -90 is up)
            gravityY: 300,
            lifespan: 3000,
            scale: { start: 1, end: 0 },
            tint: colors,
            emitting: true,
            frequency: 40,
            duration: 3000 // Stop emitting after 3 seconds
        }).setDepth(150);

        // 3. Create Right Emitter (Shooting Up and Left)
        this.add.particles(this.scale.width, this.scale.height, 'confetti', {
            speed: { min: 400, max: 700 },
            angle: { min: -150, max: -105 }, 
            gravityY: 300,
            lifespan: 3000,
            scale: { start: 1, end: 0 },
            tint: colors,
            emitting: true,
            frequency: 40,
            duration: 3000
        }).setDepth(150);
    }
}

// ========================================================================================
// 3. INITIALIZE PHASER
// ========================================================================================

const config = {
    type: Phaser.AUTO, 
    scale: {
        mode: Phaser.Scale.FIT, 
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: 600,
        height: 550
    },
    parent: 'game-container',
    backgroundColor: '#f8f8d8', 
    
    // --- HIGH QUALITY SMOOTHING SETTINGS ---
    pixelArt: false,       // Turn OFF retro pixelation
    antialias: true,       // Turn ON smoothing
    roundPixels: false,    // Turn OFF pixel snapping
    // ---------------------------------------
    
    scene: BattleScene,
    physics: {
        default: 'arcade',
        arcade: { gravity: { y: 0 } }
    }
};

const game = new Phaser.Game(config);

</script>
</body>
</html>
